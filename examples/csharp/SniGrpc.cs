// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: sni.proto
// </auto-generated>
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

public static partial class Devices
{
  static readonly string __ServiceName = "Devices";

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (message is global::Google.Protobuf.IBufferMessage)
    {
      context.SetPayloadLength(message.CalculateSize());
      global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
      context.Complete();
      return;
    }
    #endif
    context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static class __Helper_MessageCache<T>
  {
    public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (__Helper_MessageCache<T>.IsBufferMessage)
    {
      return parser.ParseFrom(context.PayloadAsReadOnlySequence());
    }
    #endif
    return parser.ParseFrom(context.PayloadAsNewBuffer());
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::DevicesRequest> __Marshaller_DevicesRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::DevicesRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::DevicesResponse> __Marshaller_DevicesResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::DevicesResponse.Parser));

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::DevicesRequest, global::DevicesResponse> __Method_ListDevices = new grpc::Method<global::DevicesRequest, global::DevicesResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "ListDevices",
      __Marshaller_DevicesRequest,
      __Marshaller_DevicesResponse);

  /// <summary>Service descriptor</summary>
  public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
  {
    get { return global::SniReflection.Descriptor.Services[0]; }
  }

  /// <summary>Base class for server-side implementations of Devices</summary>
  [grpc::BindServiceMethod(typeof(Devices), "BindService")]
  public abstract partial class DevicesBase
  {
    /// <summary>
    /// detect and list devices currently connected to the system:
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::DevicesResponse> ListDevices(global::DevicesRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

  }

  /// <summary>Client for Devices</summary>
  public partial class DevicesClient : grpc::ClientBase<DevicesClient>
  {
    /// <summary>Creates a new client for Devices</summary>
    /// <param name="channel">The channel to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DevicesClient(grpc::ChannelBase channel) : base(channel)
    {
    }
    /// <summary>Creates a new client for Devices that uses a custom <c>CallInvoker</c>.</summary>
    /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DevicesClient(grpc::CallInvoker callInvoker) : base(callInvoker)
    {
    }
    /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DevicesClient() : base()
    {
    }
    /// <summary>Protected constructor to allow creation of configured clients.</summary>
    /// <param name="configuration">The client configuration.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DevicesClient(ClientBaseConfiguration configuration) : base(configuration)
    {
    }

    /// <summary>
    /// detect and list devices currently connected to the system:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::DevicesResponse ListDevices(global::DevicesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ListDevices(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// detect and list devices currently connected to the system:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::DevicesResponse ListDevices(global::DevicesRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_ListDevices, null, options, request);
    }
    /// <summary>
    /// detect and list devices currently connected to the system:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::DevicesResponse> ListDevicesAsync(global::DevicesRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ListDevicesAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// detect and list devices currently connected to the system:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::DevicesResponse> ListDevicesAsync(global::DevicesRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_ListDevices, null, options, request);
    }
    /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected override DevicesClient NewInstance(ClientBaseConfiguration configuration)
    {
      return new DevicesClient(configuration);
    }
  }

  /// <summary>Creates service definition that can be registered with a server</summary>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static grpc::ServerServiceDefinition BindService(DevicesBase serviceImpl)
  {
    return grpc::ServerServiceDefinition.CreateBuilder()
        .AddMethod(__Method_ListDevices, serviceImpl.ListDevices).Build();
  }

  /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
  /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
  /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static void BindService(grpc::ServiceBinderBase serviceBinder, DevicesBase serviceImpl)
  {
    serviceBinder.AddMethod(__Method_ListDevices, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::DevicesRequest, global::DevicesResponse>(serviceImpl.ListDevices));
  }

}
public static partial class DeviceControl
{
  static readonly string __ServiceName = "DeviceControl";

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (message is global::Google.Protobuf.IBufferMessage)
    {
      context.SetPayloadLength(message.CalculateSize());
      global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
      context.Complete();
      return;
    }
    #endif
    context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static class __Helper_MessageCache<T>
  {
    public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (__Helper_MessageCache<T>.IsBufferMessage)
    {
      return parser.ParseFrom(context.PayloadAsReadOnlySequence());
    }
    #endif
    return parser.ParseFrom(context.PayloadAsNewBuffer());
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::ResetSystemRequest> __Marshaller_ResetSystemRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ResetSystemRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::ResetSystemResponse> __Marshaller_ResetSystemResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ResetSystemResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::ResetToMenuRequest> __Marshaller_ResetToMenuRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ResetToMenuRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::ResetToMenuResponse> __Marshaller_ResetToMenuResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ResetToMenuResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::PauseEmulationRequest> __Marshaller_PauseEmulationRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::PauseEmulationRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::PauseEmulationResponse> __Marshaller_PauseEmulationResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::PauseEmulationResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::PauseToggleEmulationRequest> __Marshaller_PauseToggleEmulationRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::PauseToggleEmulationRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::PauseToggleEmulationResponse> __Marshaller_PauseToggleEmulationResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::PauseToggleEmulationResponse.Parser));

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::ResetSystemRequest, global::ResetSystemResponse> __Method_ResetSystem = new grpc::Method<global::ResetSystemRequest, global::ResetSystemResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "ResetSystem",
      __Marshaller_ResetSystemRequest,
      __Marshaller_ResetSystemResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::ResetToMenuRequest, global::ResetToMenuResponse> __Method_ResetToMenu = new grpc::Method<global::ResetToMenuRequest, global::ResetToMenuResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "ResetToMenu",
      __Marshaller_ResetToMenuRequest,
      __Marshaller_ResetToMenuResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::PauseEmulationRequest, global::PauseEmulationResponse> __Method_PauseUnpauseEmulation = new grpc::Method<global::PauseEmulationRequest, global::PauseEmulationResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "PauseUnpauseEmulation",
      __Marshaller_PauseEmulationRequest,
      __Marshaller_PauseEmulationResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::PauseToggleEmulationRequest, global::PauseToggleEmulationResponse> __Method_PauseToggleEmulation = new grpc::Method<global::PauseToggleEmulationRequest, global::PauseToggleEmulationResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "PauseToggleEmulation",
      __Marshaller_PauseToggleEmulationRequest,
      __Marshaller_PauseToggleEmulationResponse);

  /// <summary>Service descriptor</summary>
  public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
  {
    get { return global::SniReflection.Descriptor.Services[1]; }
  }

  /// <summary>Base class for server-side implementations of DeviceControl</summary>
  [grpc::BindServiceMethod(typeof(DeviceControl), "BindService")]
  public abstract partial class DeviceControlBase
  {
    /// <summary>
    /// only available if DeviceCapability ResetSystem is present
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::ResetSystemResponse> ResetSystem(global::ResetSystemRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// only available if DeviceCapability ResetToMenu is present
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::ResetToMenuResponse> ResetToMenu(global::ResetToMenuRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// only available if DeviceCapability PauseUnpauseEmulation is present
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::PauseEmulationResponse> PauseUnpauseEmulation(global::PauseEmulationRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// only available if DeviceCapability PauseToggleEmulation is present
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::PauseToggleEmulationResponse> PauseToggleEmulation(global::PauseToggleEmulationRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

  }

  /// <summary>Client for DeviceControl</summary>
  public partial class DeviceControlClient : grpc::ClientBase<DeviceControlClient>
  {
    /// <summary>Creates a new client for DeviceControl</summary>
    /// <param name="channel">The channel to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceControlClient(grpc::ChannelBase channel) : base(channel)
    {
    }
    /// <summary>Creates a new client for DeviceControl that uses a custom <c>CallInvoker</c>.</summary>
    /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceControlClient(grpc::CallInvoker callInvoker) : base(callInvoker)
    {
    }
    /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceControlClient() : base()
    {
    }
    /// <summary>Protected constructor to allow creation of configured clients.</summary>
    /// <param name="configuration">The client configuration.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceControlClient(ClientBaseConfiguration configuration) : base(configuration)
    {
    }

    /// <summary>
    /// only available if DeviceCapability ResetSystem is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::ResetSystemResponse ResetSystem(global::ResetSystemRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ResetSystem(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability ResetSystem is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::ResetSystemResponse ResetSystem(global::ResetSystemRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_ResetSystem, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability ResetSystem is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::ResetSystemResponse> ResetSystemAsync(global::ResetSystemRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ResetSystemAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability ResetSystem is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::ResetSystemResponse> ResetSystemAsync(global::ResetSystemRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_ResetSystem, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability ResetToMenu is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::ResetToMenuResponse ResetToMenu(global::ResetToMenuRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ResetToMenu(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability ResetToMenu is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::ResetToMenuResponse ResetToMenu(global::ResetToMenuRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_ResetToMenu, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability ResetToMenu is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::ResetToMenuResponse> ResetToMenuAsync(global::ResetToMenuRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ResetToMenuAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability ResetToMenu is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::ResetToMenuResponse> ResetToMenuAsync(global::ResetToMenuRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_ResetToMenu, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability PauseUnpauseEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::PauseEmulationResponse PauseUnpauseEmulation(global::PauseEmulationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return PauseUnpauseEmulation(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability PauseUnpauseEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::PauseEmulationResponse PauseUnpauseEmulation(global::PauseEmulationRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_PauseUnpauseEmulation, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability PauseUnpauseEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::PauseEmulationResponse> PauseUnpauseEmulationAsync(global::PauseEmulationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return PauseUnpauseEmulationAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability PauseUnpauseEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::PauseEmulationResponse> PauseUnpauseEmulationAsync(global::PauseEmulationRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_PauseUnpauseEmulation, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability PauseToggleEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::PauseToggleEmulationResponse PauseToggleEmulation(global::PauseToggleEmulationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return PauseToggleEmulation(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability PauseToggleEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::PauseToggleEmulationResponse PauseToggleEmulation(global::PauseToggleEmulationRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_PauseToggleEmulation, null, options, request);
    }
    /// <summary>
    /// only available if DeviceCapability PauseToggleEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::PauseToggleEmulationResponse> PauseToggleEmulationAsync(global::PauseToggleEmulationRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return PauseToggleEmulationAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// only available if DeviceCapability PauseToggleEmulation is present
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::PauseToggleEmulationResponse> PauseToggleEmulationAsync(global::PauseToggleEmulationRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_PauseToggleEmulation, null, options, request);
    }
    /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected override DeviceControlClient NewInstance(ClientBaseConfiguration configuration)
    {
      return new DeviceControlClient(configuration);
    }
  }

  /// <summary>Creates service definition that can be registered with a server</summary>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static grpc::ServerServiceDefinition BindService(DeviceControlBase serviceImpl)
  {
    return grpc::ServerServiceDefinition.CreateBuilder()
        .AddMethod(__Method_ResetSystem, serviceImpl.ResetSystem)
        .AddMethod(__Method_ResetToMenu, serviceImpl.ResetToMenu)
        .AddMethod(__Method_PauseUnpauseEmulation, serviceImpl.PauseUnpauseEmulation)
        .AddMethod(__Method_PauseToggleEmulation, serviceImpl.PauseToggleEmulation).Build();
  }

  /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
  /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
  /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static void BindService(grpc::ServiceBinderBase serviceBinder, DeviceControlBase serviceImpl)
  {
    serviceBinder.AddMethod(__Method_ResetSystem, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ResetSystemRequest, global::ResetSystemResponse>(serviceImpl.ResetSystem));
    serviceBinder.AddMethod(__Method_ResetToMenu, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ResetToMenuRequest, global::ResetToMenuResponse>(serviceImpl.ResetToMenu));
    serviceBinder.AddMethod(__Method_PauseUnpauseEmulation, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::PauseEmulationRequest, global::PauseEmulationResponse>(serviceImpl.PauseUnpauseEmulation));
    serviceBinder.AddMethod(__Method_PauseToggleEmulation, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::PauseToggleEmulationRequest, global::PauseToggleEmulationResponse>(serviceImpl.PauseToggleEmulation));
  }

}
public static partial class DeviceMemory
{
  static readonly string __ServiceName = "DeviceMemory";

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (message is global::Google.Protobuf.IBufferMessage)
    {
      context.SetPayloadLength(message.CalculateSize());
      global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
      context.Complete();
      return;
    }
    #endif
    context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static class __Helper_MessageCache<T>
  {
    public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (__Helper_MessageCache<T>.IsBufferMessage)
    {
      return parser.ParseFrom(context.PayloadAsReadOnlySequence());
    }
    #endif
    return parser.ParseFrom(context.PayloadAsNewBuffer());
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::DetectMemoryMappingRequest> __Marshaller_DetectMemoryMappingRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::DetectMemoryMappingRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::DetectMemoryMappingResponse> __Marshaller_DetectMemoryMappingResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::DetectMemoryMappingResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::SingleReadMemoryRequest> __Marshaller_SingleReadMemoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::SingleReadMemoryRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::SingleReadMemoryResponse> __Marshaller_SingleReadMemoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::SingleReadMemoryResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::SingleWriteMemoryRequest> __Marshaller_SingleWriteMemoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::SingleWriteMemoryRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::SingleWriteMemoryResponse> __Marshaller_SingleWriteMemoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::SingleWriteMemoryResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::MultiReadMemoryRequest> __Marshaller_MultiReadMemoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::MultiReadMemoryRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::MultiReadMemoryResponse> __Marshaller_MultiReadMemoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::MultiReadMemoryResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::MultiWriteMemoryRequest> __Marshaller_MultiWriteMemoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::MultiWriteMemoryRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::MultiWriteMemoryResponse> __Marshaller_MultiWriteMemoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::MultiWriteMemoryResponse.Parser));

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::DetectMemoryMappingRequest, global::DetectMemoryMappingResponse> __Method_MappingDetect = new grpc::Method<global::DetectMemoryMappingRequest, global::DetectMemoryMappingResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "MappingDetect",
      __Marshaller_DetectMemoryMappingRequest,
      __Marshaller_DetectMemoryMappingResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::SingleReadMemoryRequest, global::SingleReadMemoryResponse> __Method_SingleRead = new grpc::Method<global::SingleReadMemoryRequest, global::SingleReadMemoryResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "SingleRead",
      __Marshaller_SingleReadMemoryRequest,
      __Marshaller_SingleReadMemoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::SingleWriteMemoryRequest, global::SingleWriteMemoryResponse> __Method_SingleWrite = new grpc::Method<global::SingleWriteMemoryRequest, global::SingleWriteMemoryResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "SingleWrite",
      __Marshaller_SingleWriteMemoryRequest,
      __Marshaller_SingleWriteMemoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse> __Method_MultiRead = new grpc::Method<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "MultiRead",
      __Marshaller_MultiReadMemoryRequest,
      __Marshaller_MultiReadMemoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse> __Method_MultiWrite = new grpc::Method<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "MultiWrite",
      __Marshaller_MultiWriteMemoryRequest,
      __Marshaller_MultiWriteMemoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse> __Method_StreamRead = new grpc::Method<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse>(
      grpc::MethodType.DuplexStreaming,
      __ServiceName,
      "StreamRead",
      __Marshaller_MultiReadMemoryRequest,
      __Marshaller_MultiReadMemoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse> __Method_StreamWrite = new grpc::Method<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse>(
      grpc::MethodType.DuplexStreaming,
      __ServiceName,
      "StreamWrite",
      __Marshaller_MultiWriteMemoryRequest,
      __Marshaller_MultiWriteMemoryResponse);

  /// <summary>Service descriptor</summary>
  public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
  {
    get { return global::SniReflection.Descriptor.Services[2]; }
  }

  /// <summary>Base class for server-side implementations of DeviceMemory</summary>
  [grpc::BindServiceMethod(typeof(DeviceMemory), "BindService")]
  public abstract partial class DeviceMemoryBase
  {
    /// <summary>
    /// detect the current memory mapping for the given device by reading $00:FFB0 header:
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::DetectMemoryMappingResponse> MappingDetect(global::DetectMemoryMappingRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// read a single memory segment with a given size from the given device:
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::SingleReadMemoryResponse> SingleRead(global::SingleReadMemoryRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// write a single memory segment with given data to the given device:
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::SingleWriteMemoryResponse> SingleWrite(global::SingleWriteMemoryRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::MultiReadMemoryResponse> MultiRead(global::MultiReadMemoryRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="request">The request received from the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>The response to send back to the client (wrapped by a task).</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::MultiWriteMemoryResponse> MultiWrite(global::MultiWriteMemoryRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// stream read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="requestStream">Used for reading requests from the client.</param>
    /// <param name="responseStream">Used for sending responses back to the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>A task indicating completion of the handler.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task StreamRead(grpc::IAsyncStreamReader<global::MultiReadMemoryRequest> requestStream, grpc::IServerStreamWriter<global::MultiReadMemoryResponse> responseStream, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    /// <summary>
    /// stream write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="requestStream">Used for reading requests from the client.</param>
    /// <param name="responseStream">Used for sending responses back to the client.</param>
    /// <param name="context">The context of the server-side call handler being invoked.</param>
    /// <returns>A task indicating completion of the handler.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task StreamWrite(grpc::IAsyncStreamReader<global::MultiWriteMemoryRequest> requestStream, grpc::IServerStreamWriter<global::MultiWriteMemoryResponse> responseStream, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

  }

  /// <summary>Client for DeviceMemory</summary>
  public partial class DeviceMemoryClient : grpc::ClientBase<DeviceMemoryClient>
  {
    /// <summary>Creates a new client for DeviceMemory</summary>
    /// <param name="channel">The channel to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceMemoryClient(grpc::ChannelBase channel) : base(channel)
    {
    }
    /// <summary>Creates a new client for DeviceMemory that uses a custom <c>CallInvoker</c>.</summary>
    /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceMemoryClient(grpc::CallInvoker callInvoker) : base(callInvoker)
    {
    }
    /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceMemoryClient() : base()
    {
    }
    /// <summary>Protected constructor to allow creation of configured clients.</summary>
    /// <param name="configuration">The client configuration.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceMemoryClient(ClientBaseConfiguration configuration) : base(configuration)
    {
    }

    /// <summary>
    /// detect the current memory mapping for the given device by reading $00:FFB0 header:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::DetectMemoryMappingResponse MappingDetect(global::DetectMemoryMappingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MappingDetect(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// detect the current memory mapping for the given device by reading $00:FFB0 header:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::DetectMemoryMappingResponse MappingDetect(global::DetectMemoryMappingRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_MappingDetect, null, options, request);
    }
    /// <summary>
    /// detect the current memory mapping for the given device by reading $00:FFB0 header:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::DetectMemoryMappingResponse> MappingDetectAsync(global::DetectMemoryMappingRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MappingDetectAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// detect the current memory mapping for the given device by reading $00:FFB0 header:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::DetectMemoryMappingResponse> MappingDetectAsync(global::DetectMemoryMappingRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_MappingDetect, null, options, request);
    }
    /// <summary>
    /// read a single memory segment with a given size from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::SingleReadMemoryResponse SingleRead(global::SingleReadMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return SingleRead(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// read a single memory segment with a given size from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::SingleReadMemoryResponse SingleRead(global::SingleReadMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_SingleRead, null, options, request);
    }
    /// <summary>
    /// read a single memory segment with a given size from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::SingleReadMemoryResponse> SingleReadAsync(global::SingleReadMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return SingleReadAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// read a single memory segment with a given size from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::SingleReadMemoryResponse> SingleReadAsync(global::SingleReadMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_SingleRead, null, options, request);
    }
    /// <summary>
    /// write a single memory segment with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::SingleWriteMemoryResponse SingleWrite(global::SingleWriteMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return SingleWrite(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// write a single memory segment with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::SingleWriteMemoryResponse SingleWrite(global::SingleWriteMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_SingleWrite, null, options, request);
    }
    /// <summary>
    /// write a single memory segment with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::SingleWriteMemoryResponse> SingleWriteAsync(global::SingleWriteMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return SingleWriteAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// write a single memory segment with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::SingleWriteMemoryResponse> SingleWriteAsync(global::SingleWriteMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_SingleWrite, null, options, request);
    }
    /// <summary>
    /// read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::MultiReadMemoryResponse MultiRead(global::MultiReadMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MultiRead(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::MultiReadMemoryResponse MultiRead(global::MultiReadMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_MultiRead, null, options, request);
    }
    /// <summary>
    /// read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::MultiReadMemoryResponse> MultiReadAsync(global::MultiReadMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MultiReadAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::MultiReadMemoryResponse> MultiReadAsync(global::MultiReadMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_MultiRead, null, options, request);
    }
    /// <summary>
    /// write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::MultiWriteMemoryResponse MultiWrite(global::MultiWriteMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MultiWrite(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The response received from the server.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::MultiWriteMemoryResponse MultiWrite(global::MultiWriteMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_MultiWrite, null, options, request);
    }
    /// <summary>
    /// write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::MultiWriteMemoryResponse> MultiWriteAsync(global::MultiWriteMemoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MultiWriteAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="request">The request to send to the server.</param>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::MultiWriteMemoryResponse> MultiWriteAsync(global::MultiWriteMemoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_MultiWrite, null, options, request);
    }
    /// <summary>
    /// stream read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncDuplexStreamingCall<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse> StreamRead(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return StreamRead(new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// stream read multiple memory segments with given sizes from the given device:
    /// </summary>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncDuplexStreamingCall<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse> StreamRead(grpc::CallOptions options)
    {
      return CallInvoker.AsyncDuplexStreamingCall(__Method_StreamRead, null, options);
    }
    /// <summary>
    /// stream write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="headers">The initial metadata to send with the call. This parameter is optional.</param>
    /// <param name="deadline">An optional deadline for the call. The call will be cancelled if deadline is hit.</param>
    /// <param name="cancellationToken">An optional token for canceling the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncDuplexStreamingCall<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse> StreamWrite(grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return StreamWrite(new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    /// <summary>
    /// stream write multiple memory segments with given data to the given device:
    /// </summary>
    /// <param name="options">The options for the call.</param>
    /// <returns>The call object.</returns>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncDuplexStreamingCall<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse> StreamWrite(grpc::CallOptions options)
    {
      return CallInvoker.AsyncDuplexStreamingCall(__Method_StreamWrite, null, options);
    }
    /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected override DeviceMemoryClient NewInstance(ClientBaseConfiguration configuration)
    {
      return new DeviceMemoryClient(configuration);
    }
  }

  /// <summary>Creates service definition that can be registered with a server</summary>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static grpc::ServerServiceDefinition BindService(DeviceMemoryBase serviceImpl)
  {
    return grpc::ServerServiceDefinition.CreateBuilder()
        .AddMethod(__Method_MappingDetect, serviceImpl.MappingDetect)
        .AddMethod(__Method_SingleRead, serviceImpl.SingleRead)
        .AddMethod(__Method_SingleWrite, serviceImpl.SingleWrite)
        .AddMethod(__Method_MultiRead, serviceImpl.MultiRead)
        .AddMethod(__Method_MultiWrite, serviceImpl.MultiWrite)
        .AddMethod(__Method_StreamRead, serviceImpl.StreamRead)
        .AddMethod(__Method_StreamWrite, serviceImpl.StreamWrite).Build();
  }

  /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
  /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
  /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static void BindService(grpc::ServiceBinderBase serviceBinder, DeviceMemoryBase serviceImpl)
  {
    serviceBinder.AddMethod(__Method_MappingDetect, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::DetectMemoryMappingRequest, global::DetectMemoryMappingResponse>(serviceImpl.MappingDetect));
    serviceBinder.AddMethod(__Method_SingleRead, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::SingleReadMemoryRequest, global::SingleReadMemoryResponse>(serviceImpl.SingleRead));
    serviceBinder.AddMethod(__Method_SingleWrite, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::SingleWriteMemoryRequest, global::SingleWriteMemoryResponse>(serviceImpl.SingleWrite));
    serviceBinder.AddMethod(__Method_MultiRead, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse>(serviceImpl.MultiRead));
    serviceBinder.AddMethod(__Method_MultiWrite, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse>(serviceImpl.MultiWrite));
    serviceBinder.AddMethod(__Method_StreamRead, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::MultiReadMemoryRequest, global::MultiReadMemoryResponse>(serviceImpl.StreamRead));
    serviceBinder.AddMethod(__Method_StreamWrite, serviceImpl == null ? null : new grpc::DuplexStreamingServerMethod<global::MultiWriteMemoryRequest, global::MultiWriteMemoryResponse>(serviceImpl.StreamWrite));
  }

}
public static partial class DeviceFilesystem
{
  static readonly string __ServiceName = "DeviceFilesystem";

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (message is global::Google.Protobuf.IBufferMessage)
    {
      context.SetPayloadLength(message.CalculateSize());
      global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
      context.Complete();
      return;
    }
    #endif
    context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static class __Helper_MessageCache<T>
  {
    public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (__Helper_MessageCache<T>.IsBufferMessage)
    {
      return parser.ParseFrom(context.PayloadAsReadOnlySequence());
    }
    #endif
    return parser.ParseFrom(context.PayloadAsNewBuffer());
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::ReadDirectoryRequest> __Marshaller_ReadDirectoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ReadDirectoryRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::ReadDirectoryResponse> __Marshaller_ReadDirectoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::ReadDirectoryResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::MakeDirectoryRequest> __Marshaller_MakeDirectoryRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::MakeDirectoryRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::MakeDirectoryResponse> __Marshaller_MakeDirectoryResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::MakeDirectoryResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::RemoveFileRequest> __Marshaller_RemoveFileRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::RemoveFileRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::RemoveFileResponse> __Marshaller_RemoveFileResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::RemoveFileResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::RenameFileRequest> __Marshaller_RenameFileRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::RenameFileRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::RenameFileResponse> __Marshaller_RenameFileResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::RenameFileResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::PutFileRequest> __Marshaller_PutFileRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::PutFileRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::PutFileResponse> __Marshaller_PutFileResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::PutFileResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::GetFileRequest> __Marshaller_GetFileRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GetFileRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::GetFileResponse> __Marshaller_GetFileResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::GetFileResponse.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::BootFileRequest> __Marshaller_BootFileRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::BootFileRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::BootFileResponse> __Marshaller_BootFileResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::BootFileResponse.Parser));

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::ReadDirectoryRequest, global::ReadDirectoryResponse> __Method_ReadDirectory = new grpc::Method<global::ReadDirectoryRequest, global::ReadDirectoryResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "ReadDirectory",
      __Marshaller_ReadDirectoryRequest,
      __Marshaller_ReadDirectoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::MakeDirectoryRequest, global::MakeDirectoryResponse> __Method_MakeDirectory = new grpc::Method<global::MakeDirectoryRequest, global::MakeDirectoryResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "MakeDirectory",
      __Marshaller_MakeDirectoryRequest,
      __Marshaller_MakeDirectoryResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::RemoveFileRequest, global::RemoveFileResponse> __Method_RemoveFile = new grpc::Method<global::RemoveFileRequest, global::RemoveFileResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "RemoveFile",
      __Marshaller_RemoveFileRequest,
      __Marshaller_RemoveFileResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::RenameFileRequest, global::RenameFileResponse> __Method_RenameFile = new grpc::Method<global::RenameFileRequest, global::RenameFileResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "RenameFile",
      __Marshaller_RenameFileRequest,
      __Marshaller_RenameFileResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::PutFileRequest, global::PutFileResponse> __Method_PutFile = new grpc::Method<global::PutFileRequest, global::PutFileResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "PutFile",
      __Marshaller_PutFileRequest,
      __Marshaller_PutFileResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::GetFileRequest, global::GetFileResponse> __Method_GetFile = new grpc::Method<global::GetFileRequest, global::GetFileResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "GetFile",
      __Marshaller_GetFileRequest,
      __Marshaller_GetFileResponse);

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::BootFileRequest, global::BootFileResponse> __Method_BootFile = new grpc::Method<global::BootFileRequest, global::BootFileResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "BootFile",
      __Marshaller_BootFileRequest,
      __Marshaller_BootFileResponse);

  /// <summary>Service descriptor</summary>
  public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
  {
    get { return global::SniReflection.Descriptor.Services[3]; }
  }

  /// <summary>Base class for server-side implementations of DeviceFilesystem</summary>
  [grpc::BindServiceMethod(typeof(DeviceFilesystem), "BindService")]
  public abstract partial class DeviceFilesystemBase
  {
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::ReadDirectoryResponse> ReadDirectory(global::ReadDirectoryRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::MakeDirectoryResponse> MakeDirectory(global::MakeDirectoryRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::RemoveFileResponse> RemoveFile(global::RemoveFileRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::RenameFileResponse> RenameFile(global::RenameFileRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::PutFileResponse> PutFile(global::PutFileRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::GetFileResponse> GetFile(global::GetFileRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::BootFileResponse> BootFile(global::BootFileRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

  }

  /// <summary>Client for DeviceFilesystem</summary>
  public partial class DeviceFilesystemClient : grpc::ClientBase<DeviceFilesystemClient>
  {
    /// <summary>Creates a new client for DeviceFilesystem</summary>
    /// <param name="channel">The channel to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceFilesystemClient(grpc::ChannelBase channel) : base(channel)
    {
    }
    /// <summary>Creates a new client for DeviceFilesystem that uses a custom <c>CallInvoker</c>.</summary>
    /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceFilesystemClient(grpc::CallInvoker callInvoker) : base(callInvoker)
    {
    }
    /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceFilesystemClient() : base()
    {
    }
    /// <summary>Protected constructor to allow creation of configured clients.</summary>
    /// <param name="configuration">The client configuration.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceFilesystemClient(ClientBaseConfiguration configuration) : base(configuration)
    {
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::ReadDirectoryResponse ReadDirectory(global::ReadDirectoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ReadDirectory(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::ReadDirectoryResponse ReadDirectory(global::ReadDirectoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_ReadDirectory, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::ReadDirectoryResponse> ReadDirectoryAsync(global::ReadDirectoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return ReadDirectoryAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::ReadDirectoryResponse> ReadDirectoryAsync(global::ReadDirectoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_ReadDirectory, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::MakeDirectoryResponse MakeDirectory(global::MakeDirectoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MakeDirectory(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::MakeDirectoryResponse MakeDirectory(global::MakeDirectoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_MakeDirectory, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::MakeDirectoryResponse> MakeDirectoryAsync(global::MakeDirectoryRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return MakeDirectoryAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::MakeDirectoryResponse> MakeDirectoryAsync(global::MakeDirectoryRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_MakeDirectory, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::RemoveFileResponse RemoveFile(global::RemoveFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return RemoveFile(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::RemoveFileResponse RemoveFile(global::RemoveFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_RemoveFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::RemoveFileResponse> RemoveFileAsync(global::RemoveFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return RemoveFileAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::RemoveFileResponse> RemoveFileAsync(global::RemoveFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_RemoveFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::RenameFileResponse RenameFile(global::RenameFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return RenameFile(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::RenameFileResponse RenameFile(global::RenameFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_RenameFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::RenameFileResponse> RenameFileAsync(global::RenameFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return RenameFileAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::RenameFileResponse> RenameFileAsync(global::RenameFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_RenameFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::PutFileResponse PutFile(global::PutFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return PutFile(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::PutFileResponse PutFile(global::PutFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_PutFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::PutFileResponse> PutFileAsync(global::PutFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return PutFileAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::PutFileResponse> PutFileAsync(global::PutFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_PutFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::GetFileResponse GetFile(global::GetFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return GetFile(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::GetFileResponse GetFile(global::GetFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_GetFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::GetFileResponse> GetFileAsync(global::GetFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return GetFileAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::GetFileResponse> GetFileAsync(global::GetFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_GetFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::BootFileResponse BootFile(global::BootFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return BootFile(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::BootFileResponse BootFile(global::BootFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_BootFile, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::BootFileResponse> BootFileAsync(global::BootFileRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return BootFileAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::BootFileResponse> BootFileAsync(global::BootFileRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_BootFile, null, options, request);
    }
    /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected override DeviceFilesystemClient NewInstance(ClientBaseConfiguration configuration)
    {
      return new DeviceFilesystemClient(configuration);
    }
  }

  /// <summary>Creates service definition that can be registered with a server</summary>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static grpc::ServerServiceDefinition BindService(DeviceFilesystemBase serviceImpl)
  {
    return grpc::ServerServiceDefinition.CreateBuilder()
        .AddMethod(__Method_ReadDirectory, serviceImpl.ReadDirectory)
        .AddMethod(__Method_MakeDirectory, serviceImpl.MakeDirectory)
        .AddMethod(__Method_RemoveFile, serviceImpl.RemoveFile)
        .AddMethod(__Method_RenameFile, serviceImpl.RenameFile)
        .AddMethod(__Method_PutFile, serviceImpl.PutFile)
        .AddMethod(__Method_GetFile, serviceImpl.GetFile)
        .AddMethod(__Method_BootFile, serviceImpl.BootFile).Build();
  }

  /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
  /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
  /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static void BindService(grpc::ServiceBinderBase serviceBinder, DeviceFilesystemBase serviceImpl)
  {
    serviceBinder.AddMethod(__Method_ReadDirectory, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::ReadDirectoryRequest, global::ReadDirectoryResponse>(serviceImpl.ReadDirectory));
    serviceBinder.AddMethod(__Method_MakeDirectory, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::MakeDirectoryRequest, global::MakeDirectoryResponse>(serviceImpl.MakeDirectory));
    serviceBinder.AddMethod(__Method_RemoveFile, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::RemoveFileRequest, global::RemoveFileResponse>(serviceImpl.RemoveFile));
    serviceBinder.AddMethod(__Method_RenameFile, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::RenameFileRequest, global::RenameFileResponse>(serviceImpl.RenameFile));
    serviceBinder.AddMethod(__Method_PutFile, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::PutFileRequest, global::PutFileResponse>(serviceImpl.PutFile));
    serviceBinder.AddMethod(__Method_GetFile, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::GetFileRequest, global::GetFileResponse>(serviceImpl.GetFile));
    serviceBinder.AddMethod(__Method_BootFile, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::BootFileRequest, global::BootFileResponse>(serviceImpl.BootFile));
  }

}
public static partial class DeviceNWA
{
  static readonly string __ServiceName = "DeviceNWA";

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static void __Helper_SerializeMessage(global::Google.Protobuf.IMessage message, grpc::SerializationContext context)
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (message is global::Google.Protobuf.IBufferMessage)
    {
      context.SetPayloadLength(message.CalculateSize());
      global::Google.Protobuf.MessageExtensions.WriteTo(message, context.GetBufferWriter());
      context.Complete();
      return;
    }
    #endif
    context.Complete(global::Google.Protobuf.MessageExtensions.ToByteArray(message));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static class __Helper_MessageCache<T>
  {
    public static readonly bool IsBufferMessage = global::System.Reflection.IntrospectionExtensions.GetTypeInfo(typeof(global::Google.Protobuf.IBufferMessage)).IsAssignableFrom(typeof(T));
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static T __Helper_DeserializeMessage<T>(grpc::DeserializationContext context, global::Google.Protobuf.MessageParser<T> parser) where T : global::Google.Protobuf.IMessage<T>
  {
    #if !GRPC_DISABLE_PROTOBUF_BUFFER_SERIALIZATION
    if (__Helper_MessageCache<T>.IsBufferMessage)
    {
      return parser.ParseFrom(context.PayloadAsReadOnlySequence());
    }
    #endif
    return parser.ParseFrom(context.PayloadAsNewBuffer());
  }

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::NWACommandRequest> __Marshaller_NWACommandRequest = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::NWACommandRequest.Parser));
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Marshaller<global::NWACommandResponse> __Marshaller_NWACommandResponse = grpc::Marshallers.Create(__Helper_SerializeMessage, context => __Helper_DeserializeMessage(context, global::NWACommandResponse.Parser));

  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  static readonly grpc::Method<global::NWACommandRequest, global::NWACommandResponse> __Method_NWACommand = new grpc::Method<global::NWACommandRequest, global::NWACommandResponse>(
      grpc::MethodType.Unary,
      __ServiceName,
      "NWACommand",
      __Marshaller_NWACommandRequest,
      __Marshaller_NWACommandResponse);

  /// <summary>Service descriptor</summary>
  public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
  {
    get { return global::SniReflection.Descriptor.Services[4]; }
  }

  /// <summary>Base class for server-side implementations of DeviceNWA</summary>
  [grpc::BindServiceMethod(typeof(DeviceNWA), "BindService")]
  public abstract partial class DeviceNWABase
  {
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::System.Threading.Tasks.Task<global::NWACommandResponse> NWACommand(global::NWACommandRequest request, grpc::ServerCallContext context)
    {
      throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
    }

  }

  /// <summary>Client for DeviceNWA</summary>
  public partial class DeviceNWAClient : grpc::ClientBase<DeviceNWAClient>
  {
    /// <summary>Creates a new client for DeviceNWA</summary>
    /// <param name="channel">The channel to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceNWAClient(grpc::ChannelBase channel) : base(channel)
    {
    }
    /// <summary>Creates a new client for DeviceNWA that uses a custom <c>CallInvoker</c>.</summary>
    /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public DeviceNWAClient(grpc::CallInvoker callInvoker) : base(callInvoker)
    {
    }
    /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceNWAClient() : base()
    {
    }
    /// <summary>Protected constructor to allow creation of configured clients.</summary>
    /// <param name="configuration">The client configuration.</param>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected DeviceNWAClient(ClientBaseConfiguration configuration) : base(configuration)
    {
    }

    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::NWACommandResponse NWACommand(global::NWACommandRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return NWACommand(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual global::NWACommandResponse NWACommand(global::NWACommandRequest request, grpc::CallOptions options)
    {
      return CallInvoker.BlockingUnaryCall(__Method_NWACommand, null, options, request);
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::NWACommandResponse> NWACommandAsync(global::NWACommandRequest request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
    {
      return NWACommandAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
    }
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    public virtual grpc::AsyncUnaryCall<global::NWACommandResponse> NWACommandAsync(global::NWACommandRequest request, grpc::CallOptions options)
    {
      return CallInvoker.AsyncUnaryCall(__Method_NWACommand, null, options, request);
    }
    /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
    [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
    protected override DeviceNWAClient NewInstance(ClientBaseConfiguration configuration)
    {
      return new DeviceNWAClient(configuration);
    }
  }

  /// <summary>Creates service definition that can be registered with a server</summary>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static grpc::ServerServiceDefinition BindService(DeviceNWABase serviceImpl)
  {
    return grpc::ServerServiceDefinition.CreateBuilder()
        .AddMethod(__Method_NWACommand, serviceImpl.NWACommand).Build();
  }

  /// <summary>Register service method with a service binder with or without implementation. Useful when customizing the service binding logic.
  /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
  /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
  /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
  [global::System.CodeDom.Compiler.GeneratedCode("grpc_csharp_plugin", null)]
  public static void BindService(grpc::ServiceBinderBase serviceBinder, DeviceNWABase serviceImpl)
  {
    serviceBinder.AddMethod(__Method_NWACommand, serviceImpl == null ? null : new grpc::UnaryServerMethod<global::NWACommandRequest, global::NWACommandResponse>(serviceImpl.NWACommand));
  }

}
#endregion
